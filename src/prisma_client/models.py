# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal

LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseConfig, BaseModel, Field, validator

from . import types, enums, errors, fields, bases
from ._types import FuncType
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField

log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()


class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    account: _str
    password: _str
    nickname: _str
    salt: _str
    created_at: Optional[datetime.datetime]
    updated_at: Optional[datetime.datetime]
    status: _int

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
            cls,
            *args: Any,
            warn_subclass: Optional[bool] = None,
            **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @staticmethod
    def create_partial(
            name: str,
            include: Optional[Iterable['types.UserKeys']] = None,
            exclude: Optional[Iterable['types.UserKeys']] = None,
            required: Optional[Iterable['types.UserKeys']] = None,
            optional: Optional[Iterable['types.UserKeys']] = None,
            relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
            exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if relations:
                raise ValueError('Model: "User" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name'      : name,
                'fields'    : cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Dict(bases.BaseDict):
    """Represents a Dict record"""

    id: _str
    main_code: _str
    sub_code: _str
    group: _str
    status: _int
    created_at: Optional[datetime.datetime]
    updated_at: Optional[datetime.datetime]
    values: Optional[List['models.DictValues']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
            cls,
            *args: Any,
            warn_subclass: Optional[bool] = None,
            **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @staticmethod
    def create_partial(
            name: str,
            include: Optional[Iterable['types.DictKeys']] = None,
            exclude: Optional[Iterable['types.DictKeys']] = None,
            required: Optional[Iterable['types.DictKeys']] = None,
            optional: Optional[Iterable['types.DictKeys']] = None,
            relations: Optional[Mapping['types.DictRelationalFieldKeys', str]] = None,
            exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Dict_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Dict_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Dict_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Dict_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Dict_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Dict_relational_fields:
                        raise errors.UnknownRelationalFieldError('Dict', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Dict / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name'      : name,
                'fields'    : cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Dict',
            }
        )
        _created_partial_types.add(name)


class DictValues(bases.BaseDictValues):
    """Represents a DictValues record"""

    id: _str
    code: _str
    value: Optional[_str]
    sort: _int
    type: _str
    created_at: Optional[datetime.datetime]
    updated_at: Optional[datetime.datetime]
    status: _int
    Dict: Optional['models.Dict']
    dictId: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
            cls,
            *args: Any,
            warn_subclass: Optional[bool] = None,
            **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @staticmethod
    def create_partial(
            name: str,
            include: Optional[Iterable['types.DictValuesKeys']] = None,
            exclude: Optional[Iterable['types.DictValuesKeys']] = None,
            required: Optional[Iterable['types.DictValuesKeys']] = None,
            optional: Optional[Iterable['types.DictValuesKeys']] = None,
            relations: Optional[Mapping['types.DictValuesRelationalFieldKeys', str]] = None,
            exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _DictValues_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _DictValues_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _DictValues_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _DictValues_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _DictValues_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _DictValues_relational_fields:
                        raise errors.UnknownRelationalFieldError('DictValues', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid DictValues / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name'      : name,
                'fields'    : cast(Mapping[str, PartialModelField], fields),
                'from_model': 'DictValues',
            }
        )
        _created_partial_types.add(name)


class Post(bases.BasePost):
    """Represents a Post record"""

    id: _str
    title: _str
    code: _str
    content: Optional[_str]
    is_deploy: _bool
    created_by: Optional[_str]
    created_at: Optional[datetime.datetime]
    updated_at: Optional[datetime.datetime]
    deploy_at: Optional[datetime.datetime]
    userId: _str
    status: _int
    tags: Optional[List['models.PostTags']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
            cls,
            *args: Any,
            warn_subclass: Optional[bool] = None,
            **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @staticmethod
    def create_partial(
            name: str,
            include: Optional[Iterable['types.PostKeys']] = None,
            exclude: Optional[Iterable['types.PostKeys']] = None,
            required: Optional[Iterable['types.PostKeys']] = None,
            optional: Optional[Iterable['types.PostKeys']] = None,
            relations: Optional[Mapping['types.PostRelationalFieldKeys', str]] = None,
            exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Post_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Post_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Post_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Post_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Post_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Post_relational_fields:
                        raise errors.UnknownRelationalFieldError('Post', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Post / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name'      : name,
                'fields'    : cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Post',
            }
        )
        _created_partial_types.add(name)


class PostCate(bases.BasePostCate):
    """Represents a PostCate record"""

    id: _str
    title: _str
    code: _str
    is_root: _bool
    parent: Optional['models.PostCate']
    status: _int
    PostCate: Optional[List['models.PostCate']]
    postCateId: Optional[_str]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
            cls,
            *args: Any,
            warn_subclass: Optional[bool] = None,
            **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @staticmethod
    def create_partial(
            name: str,
            include: Optional[Iterable['types.PostCateKeys']] = None,
            exclude: Optional[Iterable['types.PostCateKeys']] = None,
            required: Optional[Iterable['types.PostCateKeys']] = None,
            optional: Optional[Iterable['types.PostCateKeys']] = None,
            relations: Optional[Mapping['types.PostCateRelationalFieldKeys', str]] = None,
            exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PostCate_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PostCate_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PostCate_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PostCate_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PostCate_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PostCate_relational_fields:
                        raise errors.UnknownRelationalFieldError('PostCate', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PostCate / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name'      : name,
                'fields'    : cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PostCate',
            }
        )
        _created_partial_types.add(name)


class PostTags(bases.BasePostTags):
    """Represents a PostTags record"""

    id: _str
    title: _str
    code: _str
    posts: Optional[List['models.Post']]
    status: _int

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
            cls,
            *args: Any,
            warn_subclass: Optional[bool] = None,
            **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @staticmethod
    def create_partial(
            name: str,
            include: Optional[Iterable['types.PostTagsKeys']] = None,
            exclude: Optional[Iterable['types.PostTagsKeys']] = None,
            required: Optional[Iterable['types.PostTagsKeys']] = None,
            optional: Optional[Iterable['types.PostTagsKeys']] = None,
            relations: Optional[Mapping['types.PostTagsRelationalFieldKeys', str]] = None,
            exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PostTags_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PostTags_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PostTags_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PostTags_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PostTags_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PostTags_relational_fields:
                        raise errors.UnknownRelationalFieldError('PostTags', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PostTags / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name'      : name,
                'fields'    : cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PostTags',
            }
        )
        _created_partial_types.add(name)


_User_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_User_fields = OrderedDict(
    [
        ('id', {
            'name'         : 'id',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('account', {
            'name'         : 'account',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name'         : 'password',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nickname', {
            'name'         : 'nickname',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('salt', {
            'name'         : 'salt',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name'         : 'created_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name'         : 'updated_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name'         : 'status',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Dict_relational_fields: Set[str] = {
    'values',
}
_Dict_fields = OrderedDict(
    [
        ('id', {
            'name'         : 'id',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('main_code', {
            'name'         : 'main_code',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sub_code', {
            'name'         : 'sub_code',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('group', {
            'name'         : 'group',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name'         : 'status',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name'         : 'created_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name'         : 'updated_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('values', {
            'name'         : 'values',
            'is_list'      : True,
            'optional'     : True,
            'type'         : 'List[\'models.DictValues\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_DictValues_relational_fields: Set[str] = {
    'Dict',
}
_DictValues_fields = OrderedDict(
    [
        ('id', {
            'name'         : 'id',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('code', {
            'name'         : 'code',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('value', {
            'name'         : 'value',
            'is_list'      : False,
            'optional'     : True,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sort', {
            'name'         : 'sort',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name'         : 'type',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name'         : 'created_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name'         : 'updated_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name'         : 'status',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Dict', {
            'name'         : 'Dict',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'models.Dict',
            'is_relational': True,
            'documentation': None,
        }),
        ('dictId', {
            'name'         : 'dictId',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Post_relational_fields: Set[str] = {
    'tags',
}
_Post_fields = OrderedDict(
    [
        ('id', {
            'name'         : 'id',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name'         : 'title',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('code', {
            'name'         : 'code',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name'         : 'content',
            'is_list'      : False,
            'optional'     : True,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_deploy', {
            'name'         : 'is_deploy',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name'         : 'created_by',
            'is_list'      : False,
            'optional'     : True,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name'         : 'created_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name'         : 'updated_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deploy_at', {
            'name'         : 'deploy_at',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name'         : 'userId',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name'         : 'status',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tags', {
            'name'         : 'tags',
            'is_list'      : True,
            'optional'     : True,
            'type'         : 'List[\'models.PostTags\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PostCate_relational_fields: Set[str] = {
    'parent',
    'PostCate',
}
_PostCate_fields = OrderedDict(
    [
        ('id', {
            'name'         : 'id',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name'         : 'title',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('code', {
            'name'         : 'code',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_root', {
            'name'         : 'is_root',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('parent', {
            'name'         : 'parent',
            'is_list'      : False,
            'optional'     : True,
            'type'         : 'models.PostCate',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name'         : 'status',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('PostCate', {
            'name'         : 'PostCate',
            'is_list'      : True,
            'optional'     : True,
            'type'         : 'List[\'models.PostCate\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('postCateId', {
            'name'         : 'postCateId',
            'is_list'      : False,
            'optional'     : True,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_PostTags_relational_fields: Set[str] = {
    'posts',
}
_PostTags_fields = OrderedDict(
    [
        ('id', {
            'name'         : 'id',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name'         : 'title',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('code', {
            'name'         : 'code',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('posts', {
            'name'         : 'posts',
            'is_list'      : True,
            'optional'     : True,
            'type'         : 'List[\'models.Post\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name'         : 'status',
            'is_list'      : False,
            'optional'     : False,
            'type'         : '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
User.update_forward_refs()
Dict.update_forward_refs()
DictValues.update_forward_refs()
Post.update_forward_refs()
PostCate.update_forward_refs()
PostTags.update_forward_refs()
